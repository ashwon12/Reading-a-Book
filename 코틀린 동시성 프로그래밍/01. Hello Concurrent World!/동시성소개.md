# ▪️ 동시성 소개

>어떠한 입력이 들어오면 언제나 똑같은 과정을 거쳐서 항상 똑같은 결과를 내놓지만
*실행 순서는 상황에 따라 바뀌는 것*을 허락하는 코드를 **`동시성코드`** 라고 한다.

<br>

## 🧐 동시성에 대해 알아보자!!

비동시성 코드와 동시성 코드를 비교해가며 동시성이 어떤것인지 파악해보자!!!!!!!!

### **비동시성 코드**

```kotlin
fun getProfile(id: Int): Profile {
        val basicUserInfo = getUserInfo(id)
        val contactInfo = getContactInfo(id)

        return createProfile(basicUserInfo, contactInfo)
    }
```

`UserInfo` 와 `ContactInfo` 중에 어떤 것에 대한 정보를 먼저 얻게 될 것인가? 라고 했을때 순차적으로 

User 정보를 받고, 연락처 정보를 받게 될 것이라는 것을 알 수 있을 것이다. 



<br>

### 비동시성 타임라인

![스크린샷 2021-09-25 오전 1 37 00](https://user-images.githubusercontent.com/55980680/134716385-49453fd8-0fe5-42f8-ae90-5633496d783d.png)

`getProfileInfo()` 와 `getContactInfo()` 의 실행시간이 겹치지 않고  User의 정보가 다 받아와진 후에 연락처의 정보를 받아오게 된다.

 위와 같은 비동시성 코드에는 2가지의 문제점이 발생한다.

```
1. 동시성 코드에 비해 성능이 저하될 수 있다.
2. 코드가 실행되는 하드웨어를 제대로 활용하지 못할 수 있다.
```

<br>


### 동시성 코드

이번에는 동시성 코드를 살펴보자! 

```kotlin
suspend fun getProfile(id: Int): Profile {
        val basicUserInfo = asyncGetUserInfo(id)
        val contactInfo = asyncGetContactInfo(id)

        return createProfile(basicUserInfo.await(), contactInfo.await())
    }
```

`suspend` 는 '일시 중단 함수'로 지금 이 코드가 호출되는 시점에 실행을 중지할 수도 있고, 다시 시작될 수도 있다는 의미를 가지고 있다. 위에서 언급했던 `코루틴`의 특징과 같다는 사실을 알 수 있다. (코루틴 문법이다)

`asyncGetUserInfo()` 와  `asyncGetContactInfo()` 는 서로 다른 스레드에서 실행되도록 되어있다. 

연락처 정보에 대한 요청이 유저 정보의 요청이 *완료된 시점과 상관 없이 동시에 실행*되기 때문에 이 코드는 동시성 코드이다. 

만약, 유저 정보와 연락처 정보의 응답시간이 각각 1초씩이라면 비동시성에서는 2초가 걸렸겠지만 여기에서는  2초보다는 빠른 시간에 무조건 응답을 받을 것이다!


<br>

### 동시성 타임라인
![스크린샷 2021-09-25 오전 1 36 52](https://user-images.githubusercontent.com/55980680/134716382-98df76e3-a08f-4c87-8631-7b0a0973f4d9.png)

타임라인에서 살펴보면 우선 `UserInfo`와 `ContactInfo`가 동시에 요청이 되는 것을 볼 수 있다. 

하지만 둘 중에 어느 것이 먼저 요청이 완료되는지는 알 수 없다. 따라서 `await()` 을 호출하여 두가지 정보다 다 받아 와졌을 때 `createProfile()` 메서드를 호출하게 된다. 

이렇게 동시성 코드는 **상황에 따라 실행코드의 순서가 바뀌게 된다.** 하지만 결과가 달라지거나 과정이 다른 것은 아니다.  

<br>
<br>


## 🤔 동시성은 병렬성인가?

동시성 처리와 병렬성 처리가 혼동되는 경우가 많은데 두가지는 **같은 개념이 절대 아니다.**

![](https://t1.daumcdn.net/cfile/tistory/995359405FBBB9591C)

**동시성 (Concurrent)**  |  **병렬성( Parallel)** |
:-------------------------:|:-------------------------:
-동시성은 싱글 코어에서 여러개의 스레드가 문맥교환을 하며 동시에 실행되는 것처럼 보이는 것이다. <br> -사실은 동시에 실행되는게 아닌데 문맥교환을 통해 동시에 실행되는 것처럼! 보이게,,, |   - 병렬성은 실제로 여러 작업이 동시에 이뤄지고 있는 것을 말한다. <br>- 이것이 가능하기 위해서는 2개 이상의 Core와 2개 이상의 스레드가 존재해야 한다.|  


<br><br>

## 😞 동시성이 어려운 이유

- **레이스 컨디션 ( 오류 )**

동시성으로 작성했지만 순차적 코드(특정한 순서를 가지고 있다고 가정)처럼  동작할 것이라고 예상할 때 발생.

- **원자성 위반**

사용하는 데이터를 간섭 없이 접근할 수 있는 경우를 말한다. 

객체의 상태가 동시에 수정되지 않아야 하며, 상태의 수정이 겹치지 않도록 보장하는 것이 원자성인데, 

코투린이 다른 코루틴이 수정하로 깄는 데이터를 바꿀 수 있기 때문에 원자성 위반이 발생할 수 있다.

- **교착 상태**

교착상태란 두 개 이상의 작업이 서로 상대방의 작업이 끝나기 만을 기다리고 있기 때문에 결과적으로 아무것도 완료되지 못하는 상태를 가리킨다. 

동시성 코드를 동기화할때 이러한 교착상태가 발생하여 애플리케이션의 실행이 중단되는 상황이 생긴다.

- **라이브락(LiveLock)**

교착상태와 유사하며 애플리케이션의 상태는 지속적으로 변하지만 애플리케이션이 정상 실행으로 돌아오지 못하는 상태가 되는 것을 말한다.

<br><br>

##### 참조

[코틀린의 코루틴(`Coroutine`)을 어떻게 이해할것인가?](https://stylishc.tistory.com/128)

[동시성(Concurrency) vs 병렬성(Parallelism)](https://seamless.tistory.com/42)


