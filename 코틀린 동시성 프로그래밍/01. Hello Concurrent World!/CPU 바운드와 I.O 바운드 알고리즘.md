# ▪️ CPU 바운드와 I/O 바운드 알고리즘

동시성과 병렬성이 CPU , I/O 연산에서 **어떤식으로 적용**되어야 알고리즘의 성능이 더 좋아지는지에 대해 설명한다. 동시성 코드는 항상 필요한 것도 아니고 무조건 좋은 것은 아니다. `코드의 병목`과 `스레드 및 코루틴의 작동방식`을 이해하면 동시성을 언제 어떻게 구현해야 하는지 제대로 판단할 수 있다. 

## CPU 바운드

>프로세스 진행 속도가 **CPU속도**에 의해 제한된다는 의미
>CPU 성능에 따라 코드의 실행속도가 달라진다.  코드의 변경이 없이도 성능이 향상된다.

- **다중코어에서 병렬성을 활용하면 성능이 향상된다.**

`WordList` 에서 좌우가 같은 단어를 필터링할 경우, 1000개의 단어당 1개의 스레드를 생성할 수 있다.

3000개의 입력을 받을 경우 각각의 스레드를 각자의 전용코어에서 실행하게 되면 → **순차 실행의 1/3이 된다.**

- **단일코어에서 실행된다면...**

위와 같은 단어필터링 상황에서 다중코어를 사용하지 않고 단일코어를 사용하게 된다면 `문맥교환`이 빈번하게 일어나게 된다.  순차 실행에서는 문맥교환을 하지 않기 때문에 오버헤드가 발생하지 않는다.
 단일코어에서 다중 스레드를 사용하게 된다면 → **순차 실행보다 늦어질 수 있다.**

### 정리

CPU 바운드 알고리즘에서는 현재 사용중인 코어 수를 기준으로 적절한 스레드 수를 생성하는 것이 중요!

스레드 풀인 코틀린의 `CommonPool` 을 활용할 수 있음!

## I/O 바운드

>**입출력 장치**에 의존하는 알고리즘. 
>입출력 장치의 속도에 따라 실행시간이 달라진다. 코드의 변경에 따라 성능이 달라질 수 있다.

- I/O 바운드 알고리즘은 끊임없이 무언가를 기다린다.

지속적인 대기는 단일 코어에서 대기에서 대기하고 있을 때 다른 작업에 프로세스를 사용할 수 있도록 한다. → 효율성이 높아진다. 

### 정리

I/O 바운드 알고리즘은 다중코어와 단일코어에 상관없이 성능이 유사함!!

 따라서, 순차적인 알고리즘보다 동시성 구현에서 더 나은 성능을 발휘하기 때문에,**`I/O 작업은 늘 동시성으로 실행하는 편이 좋음!`**
